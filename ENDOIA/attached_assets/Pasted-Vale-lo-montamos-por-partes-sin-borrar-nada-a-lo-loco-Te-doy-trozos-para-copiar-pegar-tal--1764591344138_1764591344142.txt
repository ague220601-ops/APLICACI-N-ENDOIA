Vale, lo montamos **por partes**, sin borrar nada a lo loco üòé
Te doy trozos para copiar/pegar tal cual en Replit.

---

## üü£ PARTE 1 ‚Äì Frontend: archivo `client/src/lib/vision.ts`

üëâ Si el archivo est√° vac√≠o, pega TODO esto.
üëâ Si ya tiene cosas, lo m√°s f√°cil es **reemplazarlo entero** por esto:

```ts
// client/src/lib/vision.ts

export type RadiographMoment = 'baseline' | 'control_1m' | 'control_3m' | 'control_6m';

export interface RadiographAnalysis {
  pai: number | null;                 // PAI 1‚Äì5 estimado por IA
  radiolucencyDetected: boolean;      // true/false
  lesionDiameterMm: number | null;    // di√°metro m√°ximo estimado
  laminaDuraIntact: boolean | null;   // true = √≠ntegra, false = p√©rdida, null = no claro
  pdlWidening: 'none' | 'mild' | 'moderate' | 'severe' | null;
  borders: 'well-defined' | 'ill-defined' | null;
  comments: string;                   // mini-informe radiol√≥gico
}

/**
 * Llama al backend (/api/vision-analyze) que a su vez usa OpenAI Vision.
 * NO mete la API key en el frontend.
 */
export async function analyzeRadiographFromUrl(
  publicUrl: string,
  options: { tipo: 'periapical' | 'cbct'; momento: RadiographMoment }
): Promise<RadiographAnalysis> {
  const res = await fetch("/api/vision-analyze", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      imageUrl: publicUrl,
      tipo: options.tipo,
      momento: options.momento,
    }),
  });

  if (!res.ok) {
    console.error("Error en /api/vision-analyze:", res.status, await res.text());
    // Fallback neutro para no romper el flujo cl√≠nico
    return {
      pai: null,
      radiolucencyDetected: false,
      lesionDiameterMm: null,
      laminaDuraIntact: null,
      pdlWidening: null,
      borders: null,
      comments: "An√°lisis radiogr√°fico IA no disponible.",
    };
  }

  const data = await res.json();

  const analysis: RadiographAnalysis = {
    pai: typeof data.pai === "number" ? data.pai : null,
    radiolucencyDetected: Boolean(data.radiolucencyDetected),
    lesionDiameterMm:
      typeof data.lesionDiameterMm === "number" ? data.lesionDiameterMm : null,
    laminaDuraIntact:
      typeof data.laminaDuraIntact === "boolean" || data.laminaDuraIntact === null
        ? data.laminaDuraIntact
        : null,
    pdlWidening: data.pdlWidening ?? null,
    borders: data.borders ?? null,
    comments: typeof data.comments === "string" ? data.comments : "",
  };

  return analysis;
}
```

Con esto, el frontend ya sabe c√≥mo hablar con `/api/vision-analyze`.

---

## üü£ PARTE 2 ‚Äì Frontend: a√±adir funci√≥n nueva en `client/src/lib/radiographs.ts`

üëâ Aqu√≠ **NO borras nada**.
üëâ Solo **a√±ades imports + funci√≥n nueva**.

1. Arriba del todo, donde tengas otros imports, a√±ade:

```ts
import { analyzeRadiographFromUrl, RadiographMoment } from "./vision";
```

2. Luego, **debajo de lo que tengas** (o al final del archivo), pega esta funci√≥n nueva:

```ts
// Nueva funci√≥n: subida + an√°lisis IA + actualizaci√≥n de BD
export async function uploadRadiographWithVision(
  file: File,
  caseId: string,
  momento: RadiographMoment,
  tipo: "periapical" | "cbct"
) {
  const BUCKET_NAME = "radiographs"; // cambia si tu bucket se llama distinto

  // 1) Subir archivo al Storage
  const ext = file.name.split(".").pop() || "png";
  const filePath = `${caseId}/${momento}-${Date.now()}.${ext}`;

  const { data: storageData, error: storageError } = await supabase.storage
    .from(BUCKET_NAME)
    .upload(filePath, file);

  if (storageError) {
    console.error("Error subiendo radiograf√≠a a Storage:", storageError);
    throw storageError;
  }

  // 2) Obtener URL p√∫blica
  const { data: publicUrlData } = supabase.storage
    .from(BUCKET_NAME)
    .getPublicUrl(filePath);

  const publicUrl = publicUrlData.publicUrl;

  // 3) Buscar case_pk en tabla cases (para FK opcional)
  const { data: caseRow, error: caseError } = await supabase
    .from("cases")
    .select("id")
    .eq("case_id", caseId)
    .maybeSingle();

  if (caseError) {
    console.warn("No se pudo obtener case_pk, se insertar√° sin FK:", caseError);
  }

  // 4) Insertar fila inicial en radiographs
  const { data: inserted, error: insertError } = await supabase
    .from("radiographs")
    .insert({
      case_id: caseId,
      filepath: filePath,
      tipo,
      momento,
      fecha: new Date().toISOString().slice(0, 10), // YYYY-MM-DD
      notas: null,
      case_pk: caseRow?.id ?? null,
      pai: null,
      lesion_mm: null,
      lamina_dura: null,
      pdl_status: null,
      borders: null,
      healing: null,
    })
    .select("rad_id")
    .single();

  if (insertError) {
    console.error("Error insertando radiograf√≠a en tabla radiographs:", insertError);
    throw insertError;
  }

  // 5) Analizar radiograf√≠a con IA (OpenAI a trav√©s del backend)
  let analysis;
  try {
    analysis = await analyzeRadiographFromUrl(publicUrl, { tipo, momento });
  } catch (err) {
    console.error("Error en an√°lisis IA de radiograf√≠a:", err);
    return {
      ok: true,
      analyzed: false,
      message: "Radiograf√≠a subida, pero fall√≥ el an√°lisis IA.",
    };
  }

  // 6) Notas resumen tipo mini-informe
  const notasIA = `
[IA RADIOL√ìGICA]
PAI: ${analysis.pai ?? "no estimable"}
Radiolucidez: ${analysis.radiolucencyDetected ? "s√≠" : "no"}
Lesi√≥n (mm): ${analysis.lesionDiameterMm ?? "no visible / no estimable"}
L√°mina dura √≠ntegra: ${
    analysis.laminaDuraIntact === null
      ? "no claro"
      : analysis.laminaDuraIntact
      ? "s√≠"
      : "p√©rdida"
  }
PDL: ${analysis.pdlWidening ?? "no claro"}
Bordes de la lesi√≥n: ${analysis.borders ?? "no claro"}
Comentario IA: ${analysis.comments}
`.trim();

  // 7) Actualizar fila de radiographs con resultados IA
  const laminaDuraLabel =
    analysis.laminaDuraIntact === null
      ? "no_claro"
      : analysis.laminaDuraIntact
      ? "intacta"
      : "perdida";

  const pdlStatusLabel = analysis.pdlWidening ?? "no_claro";
  const bordersLabel = analysis.borders ?? "no_claro";

  const { error: updateRadError } = await supabase
    .from("radiographs")
    .update({
      pai: analysis.pai,
      lesion_mm: analysis.lesionDiameterMm,
      lamina_dura: laminaDuraLabel,
      pdl_status: pdlStatusLabel,
      borders: bordersLabel,
      notas: notasIA,
    })
    .eq("rad_id", inserted.rad_id);

  if (updateRadError) {
    console.error("Error actualizando radiographs con resultados IA:", updateRadError);
  }

  // 8) Actualizar tabla cases con baseline / follow-up
  const updateCases: Record<string, any> = {};

  if (momento === "baseline") {
    if (analysis.pai !== null) {
      updateCases.vision_pai_baseline = String(analysis.pai);
    }
    if (analysis.lesionDiameterMm !== null) {
      updateCases.vision_lesion_diam_mm_baseline = String(
        analysis.lesionDiameterMm
      );
    }
  } else {
    if (analysis.pai !== null) {
      updateCases.vision_pai_followup = String(analysis.pai);
    }
    if (analysis.lesionDiameterMm !== null) {
      updateCases.vision_lesion_diam_mm_followup = String(
        analysis.lesionDiameterMm
      );
    }
  }

  if (Object.keys(updateCases).length > 0) {
    const { error: updateCasesError } = await supabase
      .from("cases")
      .update(updateCases)
      .eq("case_id", caseId);

    if (updateCasesError) {
      console.error("Error actualizando cases con datos de visi√≥n:", updateCasesError);
    }
  }

  return {
    ok: true,
    analyzed: true,
    message: "Radiograf√≠a subida y analizada por IA.",
  };
}
```

3. En `ClinicoView.tsx`, de momento puedes dejar el import as√≠:

```ts
import { uploadRadiographWithVision } from "@/lib/radiographs";
```

Y cambiar la llamada:

```ts
// antes
await uploadRadiograph(radiografiaFile, caseIdGenerado, 'baseline', tipoRadiografia);

// ahora
await uploadRadiographWithVision(radiografiaFile, caseIdGenerado, 'baseline', tipoRadiografia);
```

As√≠ **no tocas** la funci√≥n antigua `uploadRadiograph`, solo usas la nueva.

---

## üü£ PARTE 3 ‚Äì Backend: archivo nuevo `server/openaiClient.ts`

Crea un archivo nuevo:

```ts
// server/openaiClient.ts

import OpenAI from "openai";

export const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});
```

(La API key ya la metiste en los Secrets de Replit).

---

## üü£ PARTE 4 ‚Äì Backend: a√±adir la ruta `/api/vision-analyze` en `server/index.ts`

En tu `server/index.ts` (o el archivo principal del servidor Express), haz tres cosas:

### 4.1 Importar el cliente

Arriba con el resto de imports:

```ts
import { openai } from "./openaiClient";
```

### 4.2 Aseg√∫rate de tener lo b√°sico

Ya deber√≠as tener algo as√≠:

```ts
const app = express();

app.use(cors());
app.use(express.json());

// ... otras rutas
```

### 4.3 Debajo de esas rutas, pega ESTA ruta nueva:

```ts
app.post("/api/vision-analyze", async (req, res) => {
  try {
    const { imageUrl, tipo, momento } = req.body as {
      imageUrl: string;
      tipo: "periapical" | "cbct";
      momento: string;
    };

    if (!imageUrl) {
      return res.status(400).json({ error: "imageUrl requerido" });
    }

    const systemPrompt = `
Eres un asistente experto en radiolog√≠a endod√≥ntica.
Analiza la imagen (${tipo}, momento cl√≠nico: ${momento}) y devuelve SOLO un JSON v√°lido con este formato exacto:

{
  "pai": number | null,
  "radiolucencyDetected": boolean,
  "lesionDiameterMm": number | null,
  "laminaDuraIntact": true | false | null,
  "pdlWidening": "none" | "mild" | "moderate" | "severe" | null,
  "borders": "well-defined" | "ill-defined" | null,
  "comments": string
}

No a√±adas nada fuera del JSON.
Si no puedes valorar algo con seguridad, usa null.
`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4.1-mini", // o el modelo que tengas con visi√≥n
      messages: [
        { role: "system", content: systemPrompt },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: "Analiza esta radiograf√≠a y devuelve SOLO el JSON pedido.",
            },
            {
              type: "image_url",
              image_url: { url: imageUrl },
            } as any,
          ],
        },
      ],
      max_tokens: 400,
    });

    const content = completion.choices[0]?.message?.content;

    if (!content) {
      return res
        .status(500)
        .json({ error: "Respuesta vac√≠a del modelo de visi√≥n" });
    }

    let text: string;

    if (typeof content === "string") {
      text = content;
    } else if (Array.isArray(content)) {
      const textPart = content.find((p: any) => p.type === "text");
      text = textPart?.text ?? JSON.stringify(content);
    } else {
      text = String(content);
    }

    const firstBrace = text.indexOf("{");
    const lastBrace = text.lastIndexOf("}");
    if (firstBrace === -1 || lastBrace === -1) {
      return res.status(500).json({
        error: "La IA no devolvi√≥ un JSON reconocible",
        raw: text,
      });
    }

    const jsonText = text.slice(firstBrace, lastBrace + 1);
    let parsed: any;

    try {
      parsed = JSON.parse(jsonText);
    } catch (err) {
      console.error("Error parseando JSON de OpenAI:", err, jsonText);
      return res.status(500).json({
        error: "No se pudo parsear el JSON devuelto por la IA",
        raw: jsonText,
      });
    }

    const result = {
      pai: typeof parsed.pai === "number" ? parsed.pai : null,
      radiolucencyDetected: Boolean(parsed.radiolencuyDetected ?? parsed.radiolucencyDetected),
      lesionDiameterMm:
        typeof parsed.lesionDiameterMm === "number"
          ? parsed.lesionDiameterMm
          : null,
      laminaDuraIntact:
        typeof parsed.laminaDuraIntact === "boolean" ||
        parsed.laminaDuraIntact === null
          ? parsed.laminaDuraIntact
          : null,
      pdlWidening: parsed.pdlWidening ?? null,
      borders: parsed.borders ?? null,
      comments: typeof parsed.comments === "string" ? parsed.comments : "",
    };

    return res.json(result);
  } catch (err) {
    console.error("Error en /api/vision-analyze:", err);
    return res.status(500).json({ error: "Error interno en an√°lisis IA" });
  }
});
```

(Col√≥calo **antes** del `app.listen(...)` o del `export default app`, seg√∫n c√≥mo lo tengas.)

---

Cuando pegues todo esto:

1. Replit arranca server.
2. Subes un caso con radiograf√≠a.
3. En Supabase ‚Üí `radiographs` ver√°s `pai`, `lesion_mm`, `lamina_dura`, `pdl_status`, `borders`, `notas`.
4. En `cases` ‚Üí `vision_pai_baseline` y `vision_lesion_diam_mm_baseline` rellenos.

Si al probar te sale alg√∫n error concreto (l√≠nea X, archivo Y), me lo pegas y lo ajustamos fino.
