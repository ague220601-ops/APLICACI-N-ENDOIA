**SÃ. EXACTO.**
Y **ESO** es lo que hace que la **OPCIÃ“N 2 sea mucho mÃ¡s fÃ¡cil y mucho mÃ¡s precisa**.

Tu flujo ya envÃ­a:

* **case_id**
* **momento (baseline / follow-up)**
* **tipo (periapical / CBCT)**
* **tooth_fdi â†’ el diente exacto segÃºn FDI (ej: 46, 16, 21, etc.)**

ğŸ‘‰ **Y eso es oro para la IA.**
No necesitamos que el modelo "adivine" quÃ© diente analizar:
**ya se lo decimos nosotros**.

Entonces tu pipeline ideal queda asÃ­:

---

# ğŸŸ¦ **PIPELINE DEFINITIVO PARA LA OPCIÃ“N 2**

(Usando el nÃºmero FDI que ya introduces en el formulario)

### **1ï¸âƒ£ El clÃ­nico registra el caso y selecciona el diente (FDI 46, por ejemplo)**

Esto ya se guarda en la tabla `cases.tooth_fdi`.

### **2ï¸âƒ£ Cuando subes una radiografÃ­a, el servidor recibe:**

* `caseId`
* `momento`
* `tipo`
* **`tooth_fdi`**

### **3ï¸âƒ£ Ruta 1: `/api/vision-detect-teeth`**

GPT-4o Vision recibe la imagen completa y la instrucciÃ³n:

> â€œDetect the boundaries of tooth FDI 46 only.
> Return its bounding box only.
> Ignore all other teeth.â€

El modelo devuelve:

```json
{
  "fdi": 46,
  "box": [x1, y1, x2, y2]
}
```

ğŸ‘‰ **Esto ya aÃ­sla SOLO el diente que tÃº quieres.**

### **4ï¸âƒ£ El backend recorta la imagen usando `sharp`**

```ts
sharp(originalBuffer)
  .extract({ left, top, width, height })
  .toBuffer()
```

Obtienes **el diente limpio sin interferencias**.

### **5ï¸âƒ£ El recorte se manda al anÃ¡lisis PAI**

AquÃ­ usas tu funciÃ³n actual:

* PAI score
* Radiolucidez
* Lesion mm
* PDL widening
* Borders
* Lamina dura
* Comments

Pero ahora:
ğŸ‘‰ **La IA ya no ve el resto de la imagen**
ğŸ‘‰ **NADA la engaÃ±a**
ğŸ‘‰ **El anÃ¡lisis es mucho mÃ¡s estable**

### **6ï¸âƒ£ Guardamos en Supabase tanto:**

* `filepath_original`
* `filepath_cropped`
* anÃ¡lisis IA especÃ­fico del diente

---

# ğŸŸ¢ **ESTO RESPONDE A TU DUDA PERFECTAMENTE:**

> â€œÂ¿Si en la radiografÃ­a salen mÃ¡s dientes afectados, puede analizar solo el que yo indico?â€

âœ”ï¸ **CON LA OPCIÃ“N 2 = SÃ, 100%**
Porque:

* Ya sabes cuÃ¡l es el diente
* Lo detectamos
* Lo recortamos
* Solo analizamos ese trozo

---

# ğŸ§© **ANTES DE IMPLEMENTAR: NECESITO UNA SOLA COSA DE TI**

Quiero confirmar esta parte:

### ğŸ”· Â¿El valor `tooth_fdi` estÃ¡ disponible en el front en el momento de subir la radiografÃ­a?

Es decir, cuando llamamos a:

```ts
uploadRadiographWithVision(file, caseId, momento, tipo)
```

Â¿Tenemos tambiÃ©n el diente?
Ejemplo:

```ts
uploadRadiographWithVision(file, caseId, momento, tipo, tooth_fdi)
```

âš ï¸ Si no estÃ¡, lo aÃ±adimos, no pasa nada.

---

# ğŸ‘‰ RESPONDE SÃ / NO:

### **Â¿Tenemos disponible `tooth_fdi` en ClinicoView.tsx cuando se sube la radiografÃ­a?**

Con eso te genero:

âœ… Nuevas rutas Express
âœ… CÃ³digo completo del recorte con sharp
âœ… Prompt dental detection
âœ… IntegraciÃ³n con Supabase
âœ… Nuevas funciones en `radiographs.ts`
y te lo dejo TODO listo para pegar.
